package kind;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;


import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.JsonObject;


import config.Config;


@Path("")
public class RESTServices {
	private final boolean debug=false;
	private static final Logger log = Logger.getLogger(RESTServices.class);

	public static final String ERROR_INTERNAL="1";
	public static final String ERROR_NOJOB="2";
	public static final String ERROR_INVALIDPARAM="3";
	public static final String[] specialAttrs={"code","kind"}; // these are attributes that kind expects specifically
	public static final HTTPKindClient client=new HTTPKindClient();
	private static Gson gson = new Gson();
	
	
	private static String getURL() {
		String[] portAndHost=Config.getSystemPortAndHostFromConfigFile();
		return portAndHost[1]+":"+portAndHost[0];
	}
	
	@POST
	@Path("/saveCode")
	@Produces("application/json")
	public String saveFile(@Context HttpServletRequest request) {
		try {
			String fileId=Constants.tempPrefix+UUID.randomUUID().toString();
			File dir=new File(Constants.ROOT_PATH,Constants.JOB_PATH);
			File jobDir=new File(dir,fileId);
			jobDir.mkdir();
			File saveFile=new File(jobDir,Constants.CODE_FILE);
			Util.writeToFile(request.getParameter("code"), saveFile);
			return fileId;
		} catch (Exception e) {
			log.error("saveFile says "+e.getMessage(),e);
		}
		return ERROR_INTERNAL;
		
	}
	/**
	 * Submits code for starting a new Kind job. A job ID for referencing the job created by this request will be returns.
	 * @param request The HTTP request generated by the client
	 * @return The job ID of this job as a string
	 */
	@POST
	@Path("/postCode")
	@Produces("application/json")	
	public String initRequest(@Context HttpServletRequest request) {		
		try {
			//save the code to a file to submit to the kind server
			String fileName=Constants.tempPrefix+UUID.randomUUID().toString();
			File dir=new File(Constants.ROOT_PATH,Constants.JOB_PATH);
			
			File inputFile=new File(dir,fileName);
			
			//the user sends over which kind is being used, and from that the 
			String kind=request.getParameter("kind");
			Util.writeToFile(request.getParameter("code"), inputFile);
		
			List<String> args =new ArrayList<String>();
			//get all arguments to the kind server
			Enumeration<String> names=request.getParameterNames();
			while (names.hasMoreElements()) {
				String curName=names.nextElement();
				if (Util.containsIgnoreCase(specialAttrs, curName)) {
					continue; //we handle the special attrs differently
				}
				String curValue=request.getParameter(curName);
				if (!Validator.isArgValid(kind,curName,curValue)) {
					return ERROR_INVALIDPARAM;
				}
				//if it's a flag, don't add the value
				if (curValue=="") {
					log.debug("found flag "+curName);
					args.add(curName);
				} else {
					log.debug("found arg "+curName+" = "+curValue);
					//otherwise, add the name and value
					args.add(curName);
					args.add(curValue);
				}
				
			}
			String jobId=null;
			if (debug) {
				jobId=UUID.randomUUID().toString();
			} else {
				jobId=XMLHandler.getJobId(client.createJob(inputFile.getAbsolutePath(),args,getURL(),kind));
			}
			if (jobId==null || jobId.isEmpty()) {
				log.debug("An empty job ID was returned");
				return jobId; //no error, but means the server is not accepting jobs for some reason
			}
			jobId=Constants.tempPrefix+jobId;
			System.out.println("got this job ID = "+jobId);
			File jobDir=new File(dir,jobId);
			jobDir.mkdir();
			File saveFile=new File(jobDir,Constants.CODE_FILE);
			File infoFile=new File(jobDir,Constants.INFO_FILE);
			
			XMLHandler.generateJobInfoFile(kind, "propertyChecker", infoFile);
			
			
			FileUtils.copyFile(inputFile, saveFile);
			return jobId;
		} catch (Exception e) {
			log.error("initRequest says "+e.getMessage(),e);
		}
		return ERROR_INTERNAL; //error code
	}
	
	//TODO: Are arguments to KIND necessary here? 
	@POST
	@Path("/initInterpreter")
	@Produces("application/json")	
	public String initInterpreter(@Context HttpServletRequest request) {		
		try {
			//save the code to a file to submit to the kind server
			String fileName=UUID.randomUUID().toString();
			File dir=new File(Constants.ROOT_PATH,Constants.JOB_PATH);
			
			File inputFile=new File(dir,fileName);
			
			//the user sends over which kind is being used, and from that the 
			String kind=request.getParameter("kind");
			Util.writeToFile(request.getParameter("code"), inputFile);
			List<String> args =new ArrayList<String>();
			//get all arguments to the kind server
			Enumeration<String> names=request.getParameterNames();
			while (names.hasMoreElements()) {
				String curName=names.nextElement();
				
				if (Util.containsIgnoreCase(specialAttrs, curName)) {
					continue; //we handle the special attrs differently
				}
				String[] curValues=request.getParameterValues(curName);
				
				String curValue=curValues[0];
				if (curValue=="") {
					log.debug("found flag "+curName);
					args.add(curName);
				} else {
					if (!Validator.isArgValid(kind,curName,curValue)) {
						return ERROR_INVALIDPARAM;
					}
					log.debug("found arg "+curName+" = "+curValue);
					//otherwise, add the name and value
					args.add(curName);
					args.add(curValue);
				}
			}
			//these arguments are needed for every interpreter job
			args.add("--enable");
			args.add("interpreter");
			String XML =null;
			
			XML=client.initInterpreter(inputFile.getAbsolutePath(),args,getURL());
			XML=XMLHandler.fixXML(XML);

			if (XML==null || XML=="") {
				log.debug("An empty XML was returned");
				return XML; 
			}
			

			return XML;
		} catch (Exception e) {
			log.error("initRequest says "+e.getMessage(),e);
		}
		return ERROR_INTERNAL; //error code
	}
	
	@POST
	@Path("/interpreter")
	@Produces("application/json")	
	public String initInterpreterJob(@Context HttpServletRequest request) {		
		try {
			//save the code to a file to submit to the kind server
			String fileName=UUID.randomUUID().toString();
			String CSVfileName=fileName+".csv";
			File dir=new File(Constants.ROOT_PATH,Constants.JOB_PATH);
			
			File inputFile=new File(dir,fileName);
			File CSVFile=new File(dir,CSVfileName);
			
			//the user sends over which kind is being used, and from that the 
			StringBuilder csvBuilder=new StringBuilder();
			Util.writeToFile(request.getParameter("code"), inputFile);
			//get all arguments to the kind server
			Enumeration<String> names=request.getParameterNames();
			while (names.hasMoreElements()) {
				String curName=names.nextElement();
				
				if (Util.containsIgnoreCase(specialAttrs, curName)) {
					continue; //we handle the special attrs differently
				}
				String[] curValues=request.getParameterValues(curName);
				if (curValues[0].startsWith("INPUT:")) {
					curValues[0]=curValues[0].substring(6);
					csvBuilder.append(curValues[0]);
					for (int x=1;x<curValues.length;x++) {
						csvBuilder.append(',');
						csvBuilder.append(curValues[x]);
					}
					csvBuilder.append("\n");
				}
			}
			Util.writeToFile(csvBuilder.toString(), CSVFile);
			//these arguments are needed for every interpreter job

			
			String xml=XMLHandler.fixXML(client.runInterpreter(inputFile.getAbsolutePath(),CSVFile.getAbsolutePath(),getURL()));
			
			if (xml==null || xml=="") {
				
				log.debug("An empty result was returned");
				return xml; //no error, but means the server is not accepting jobs for some reason
			}
			return xml;
		} catch (Exception e) {
			log.error("initRequest says "+e.getMessage(),e);
		}
		return ERROR_INTERNAL; //error code
	}
	
	@GET
	@Path("/getJob/{id}")
	@Produces("application/json")
	public String getJobCode(@PathParam("id") String id, @Context HttpServletRequest request) {
		try {
			File file=new File(new File(Constants.ROOT_PATH,Constants.JOB_PATH),id);
			File infoFile=new File(file,Constants.INFO_FILE);
			file=new File(file,Constants.CODE_FILE);
			
			if (!file.exists()) {
				log.debug("could not find job with id = "+id);
				return gson.toJson(ERROR_NOJOB);
			}
			
			String text=FileUtils.readFileToString(file);
			JsonObject object=new JsonObject();
			object.addProperty("text", text);
			//if no info file exists, we are just retrieving a source code file, not a job
			object.addProperty("isJob",infoFile.exists());
			
			return gson.toJson(object);
		} catch (Exception e) {
			log.error("getJobCode says "+e.getMessage(),e);
		}
		return ERROR_INTERNAL;
	}
	
	/**
	 * Submits code for starting a new Kind job. A job ID for referencing the job created by this request will be returns.
	 * @param request The HTTP request generated by the client
	 * @return The job ID of this job as a string
	 */
	@GET
	@Path("/getResults/{id}/{old}")
	@Produces("application/json")	
	public String getJobInfo(@PathParam("id") String id, @PathParam("old") boolean getHistoric, @Context HttpServletRequest request) {		
		try {
			if (debug) { 
				//File test=new File("C:/Users/Eric/Desktop/Kind Things/KindXML/multi_two_counters.ec.xml");
				File test=new File("C:/Users/Eric/Desktop/kexample.txt");
				BufferedReader reader=new BufferedReader(new FileReader(test));
				String line;
				StringBuilder sb = new StringBuilder();

				while((line=reader.readLine())!= null){
				    sb.append(line.trim());
				}
				String xml=sb.toString();
				String oldData="";
				//add all the old data to what we are returning normally
				if (getHistoric) {
					File file=new File(new File(Constants.ROOT_PATH,Constants.JOB_PATH),id);
					file=new File(file,Constants.RESULTS_FILE);
					oldData=FileUtils.readFileToString(file);
				}
				Util.appendToJobResultsFile(id,xml);
				xml=XMLHandler.fixXML(oldData+xml);
				log.debug(xml);
				return xml;
				//return "<Jobstatus msg=\"completed\">done</Jobstatus>";
			} else {
				//it is possible our "job id" includes the temp prefix, which we should exclude
				String data=client.retrieve(id.replace(Constants.tempPrefix, ""),getURL());
				
				log.debug("the unfixed data is "+data);
				if (data!=null) {
					String oldData="";
					//add all the old data to what we are returning normally
					if (getHistoric) {
						File file=new File(new File(Constants.ROOT_PATH,Constants.JOB_PATH),id);
						file=new File(file,Constants.RESULTS_FILE);
						oldData=FileUtils.readFileToString(file);
					}
					
					Util.appendToJobResultsFile(id, data);
					data=data+oldData;
					data=XMLHandler.fixXML(data);
					log.debug("the fixed data is "+data);
					return data;
				} else {
					return ERROR_INTERNAL;
				}
			}	
		} catch (Exception e) {
			log.error("getJobInfo says "+e.getMessage(),e);
		}
		
		return ERROR_INTERNAL;
	}	
	
	/**
	 * Submits code for starting a new Kind job. A job ID for referencing the job created by this request will be returns.
	 * @param request The HTTP request generated by the client
	 * @return The job ID of this job as a string
	 */
	@GET
	@Path("/cancel/{id}")
	@Produces("application/json")	
	public String cancelJob(@PathParam("id") String id, @Context HttpServletRequest request) {		
		try {
			String data=client.cancel(id.replace(Constants.tempPrefix, ""),getURL());
			if (data!= null){
				return data;
			} else {
				return ERROR_INTERNAL;
			}
			
		} catch (Exception e) {
			log.error("getJobInfo says "+e.getMessage(),e);
		}
		
		return ERROR_INTERNAL;
	}	
}
